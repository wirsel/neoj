//GITHUB url extraxt apoc folders

With {
    level:3,
    batchSize:1,
    parallel:true,
    concurrency:3,
    baseurl: 'https://github.com', 
    offseturl: 'https://github.com/neo4j-contrib/neo4j-apoc-procedures/tree/3.5/src/main/java/apoc',
    split1: 'href="',
    split2: '">',
    maxiteration: 0

} as c
//-------------------
With *, '
WITH { 
    dt: datetime(),
    baseurl: \'<<baseurl>>\' , 
    offseturl: \'<<offseturl>>\', 
    split1: \'<<split1>>\', 
    split2: \'<<split2>>\',
    level: <<level>>,
    maxiteration: <<maxiteration>>
} as c
MATCH (u:C_url)
where u.level = c.level 
With c, u, u.identifier as id order by id
With c, 
COLLECT(u) as urls
With urls, apoc.map.mergeList([ c, { maxindex: size(urls)-1} ]) as c
With *, CASE WHEN c.maxiteration > 0 and not (0 + c.maxiteration) > c.maxindex THEN c.maxiteration ELSE c. maxindex END as maxrng

UNWIND range(0, maxrng) as x
With *, urls[x] as url
With apoc.map.mergeList([ c, { index:x, url:url.identifier} ]) as cc
return cc as c
'
AS str
With *, reduce( s=str, x in keys(c) | replace(s,'<<'+x+'>>', toString(c[x])) )
AS statementIteration
//----------------------
With *,'
MERGE( t:C_trace {identifier: apoc.convert.toString(c.dt) })
On create set t.dt = c.dt,  t.type = \'C_trace\'

set t. urls = coalesce(t.urls, [])+ [coalesce( apoc.convert.toString( c.url ), \' null\' )]
set t. baseurl = coalesce( apoc.convert.toString( c.baseurl ), \' null\' )
set t. offseturl = coalesce( apoc.convert.toString( c.offseturl ), \' null\' )
set t. split1 = coalesce( apoc.convert.toString( c.split1 ), \' null\' )
set t. split2 = coalesce( apoc.convert.toString( c.split2 ), \' null\' )
set t. level = coalesce( apoc.convert.toString( c.level ), \' null\' )
set t. maxstep = coalesce( apoc.convert.toString( c.maxindex + 1), \' null\' )
set t. step = coalesce( apoc.convert.toString( c.index +1), \' null\' )
set t. progress = coalesce( apoc.convert.toString( c.index +1)+\'/\'+ apoc.convert.toString( c.maxindex +1), \' null\' )

Set t.cnt= coalesce( t.cnt, 0) + 1
With *
LOAD CSV FROM c.url as line
With t, c, 
COLLECT(line[0]) as lines
With *, apoc.text.join(lines, \' \') as content

set t.contentlist = coalesce(t. contentlist, [])+ [coalesce( size(apoc.convert.toString( content )), \' null\' )]

with *, filter(x in lines where x contains \'href\' and x contains \'neo4j-contrib/neo4j-apoc-procedures/tree/3.5/src/main/java/apoc\' and trim(x) starts with \'<span class\') as flines
With *, [x in flines |  c.baseurl + (split(split(x, c.split1 )[1], c.split2) [0] )] as longurls
With *, [x in longurls |  replace(x,c.offseturl,\'\') ] as shorturls

set t. shorturlslist = coalesce(t. shorturlslist, [])+ [coalesce( apoc.convert.toString( shorturls ), \' null\' )]

set t. longurlslist = coalesce(t. longurlslist, [])+ [coalesce( apoc.convert.toString( longurls ), \' null\' )]

With *

CALL apoc.do.when(longurls=[],
\' with $t as t set t.urlids = coalesce(t.urlids, [])+[apoc.convert.toString([])]
\',\'\', { t:t } ) yield value


With *
UNWIND range(0, size(longurls)-1) as x
With *, longurls[x] as longurl, shorturls[x] as shorturl
MERGE(lu:C_url {identifier: longurl})
Set lu.name=lu.identifier
Set lu.name_short = shorturl
Set lu.type=\'C_url\'
Set lu.level=c.level+1
Set lu.tracedt=c.dt
Set lu.linkedby=coalesce(c.url,\'null\')
//MERGE(purl)-[le:LINKS_TO]->(lu)
With t, c, COLLECT(id(lu)) as urlids

set t.urlids = coalesce(t.urlids, [])+ [coalesce( apoc.convert.toString( urlids ), \' null\' )]


Return t
'
As statementAction



CALL apoc.periodic.iterate(statementIteration, statementAction, {batchSize:c.batchSize, parallel:c.parallel, concurrency: c.concurrency} ) YIELD batches , total , timeTaken , committedOperations , failedOperations , failedBatches , retries , errorMessages , batch , operations , wasTerminated , failedParams 

return batches , total , timeTaken , committedOperations , failedOperations , failedBatches , retries , errorMessages , batch , operations , wasTerminated , failedParams